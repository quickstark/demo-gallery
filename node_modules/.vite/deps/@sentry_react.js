import {
  require_hoist_non_react_statics_cjs
} from "./chunk-OLS74FIL.js";
import {
  require_react
} from "./chunk-HDQFBXFU.js";
import {
  BaseClient,
  FunctionToString,
  GLOBAL_OBJ,
  Hub,
  InboundFilters,
  SDK_VERSION,
  Scope,
  SyncPromise,
  addBreadcrumb,
  addExceptionMechanism,
  addExceptionTypeValue,
  addGlobalEventProcessor,
  addInstrumentationHandler,
  addNonEnumerableProperty,
  captureEvent,
  captureException,
  captureMessage,
  configureScope,
  createClientReportEnvelope,
  createStackParser,
  createTransport,
  dsnToString,
  extractExceptionKeysForMessage,
  fill,
  getCurrentHub,
  getEnvelopeEndpointWithUrlEncodedAuth,
  getEventDescription,
  getFunctionName,
  getHubFromCarrier,
  getIntegrationsToSetup,
  getLocationHref,
  getNumberOfUrlSegments,
  getOriginalFunction,
  getReportDialogEndpoint,
  htmlTreeAsString,
  initAndBind,
  integrations_exports,
  isDOMError,
  isDOMException,
  isError,
  isErrorEvent,
  isEvent,
  isInstanceOf,
  isNativeFetch,
  isPlainObject,
  isPrimitive,
  isString,
  logger,
  makeMain,
  markFunctionWrapped,
  normalizeToSize,
  parseUrl,
  rejectedSyncPromise,
  resolvedSyncPromise,
  safeJoin,
  serializeEnvelope,
  setContext,
  setExtra,
  setExtras,
  setTag,
  setTags,
  setUser,
  severityLevelFromString,
  stackParserFromStackParserOptions,
  startTransaction,
  supportsFetch,
  timestampWithMs,
  withScope
} from "./chunk-V4Y5MC3S.js";
import {
  __export,
  __toESM
} from "./chunk-BGRLPBYH.js";

// node_modules/@sentry/browser/esm/helpers.js
var WINDOW = GLOBAL_OBJ;
var ignoreOnError = 0;
function shouldIgnoreOnError() {
  return ignoreOnError > 0;
}
function ignoreNextOnError() {
  ignoreOnError += 1;
  setTimeout(() => {
    ignoreOnError -= 1;
  });
}
function wrap(fn, options = {}, before) {
  if (typeof fn !== "function") {
    return fn;
  }
  try {
    const wrapper = fn.__sentry_wrapped__;
    if (wrapper) {
      return wrapper;
    }
    if (getOriginalFunction(fn)) {
      return fn;
    }
  } catch (e) {
    return fn;
  }
  const sentryWrapped = function() {
    const args = Array.prototype.slice.call(arguments);
    try {
      if (before && typeof before === "function") {
        before.apply(this, arguments);
      }
      const wrappedArguments = args.map((arg) => wrap(arg, options));
      return fn.apply(this, wrappedArguments);
    } catch (ex) {
      ignoreNextOnError();
      withScope((scope) => {
        scope.addEventProcessor((event) => {
          if (options.mechanism) {
            addExceptionTypeValue(event, void 0, void 0);
            addExceptionMechanism(event, options.mechanism);
          }
          event.extra = {
            ...event.extra,
            arguments: args
          };
          return event;
        });
        captureException(ex);
      });
      throw ex;
    }
  };
  try {
    for (const property in fn) {
      if (Object.prototype.hasOwnProperty.call(fn, property)) {
        sentryWrapped[property] = fn[property];
      }
    }
  } catch (_oO) {
  }
  markFunctionWrapped(sentryWrapped, fn);
  addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
  try {
    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
    if (descriptor.configurable) {
      Object.defineProperty(sentryWrapped, "name", {
        get() {
          return fn.name;
        }
      });
    }
  } catch (_oO) {
  }
  return sentryWrapped;
}

// node_modules/@sentry/browser/esm/eventbuilder.js
function exceptionFromError(stackParser, ex) {
  const frames = parseStackFrames(stackParser, ex);
  const exception = {
    type: ex && ex.name,
    value: extractMessage(ex)
  };
  if (frames.length) {
    exception.stacktrace = { frames };
  }
  if (exception.type === void 0 && exception.value === "") {
    exception.value = "Unrecoverable error caught";
  }
  return exception;
}
function eventFromPlainObject(stackParser, exception, syntheticException, isUnhandledRejection) {
  const hub = getCurrentHub();
  const client = hub.getClient();
  const normalizeDepth = client && client.getOptions().normalizeDepth;
  const event = {
    exception: {
      values: [
        {
          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
          value: `Non-Error ${isUnhandledRejection ? "promise rejection" : "exception"} captured with keys: ${extractExceptionKeysForMessage(exception)}`
        }
      ]
    },
    extra: {
      __serialized__: normalizeToSize(exception, normalizeDepth)
    }
  };
  if (syntheticException) {
    const frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      event.exception.values[0].stacktrace = { frames };
    }
  }
  return event;
}
function eventFromError(stackParser, ex) {
  return {
    exception: {
      values: [exceptionFromError(stackParser, ex)]
    }
  };
}
function parseStackFrames(stackParser, ex) {
  const stacktrace = ex.stacktrace || ex.stack || "";
  const popSize = getPopSize(ex);
  try {
    return stackParser(stacktrace, popSize);
  } catch (e) {
  }
  return [];
}
var reactMinifiedRegexp = /Minified React error #\d+;/i;
function getPopSize(ex) {
  if (ex) {
    if (typeof ex.framesToPop === "number") {
      return ex.framesToPop;
    }
    if (reactMinifiedRegexp.test(ex.message)) {
      return 1;
    }
  }
  return 0;
}
function extractMessage(ex) {
  const message = ex && ex.message;
  if (!message) {
    return "No error message";
  }
  if (message.error && typeof message.error.message === "string") {
    return message.error.message;
  }
  return message;
}
function eventFromException(stackParser, exception, hint, attachStacktrace) {
  const syntheticException = hint && hint.syntheticException || void 0;
  const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);
  addExceptionMechanism(event);
  event.level = "error";
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}
function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
  const syntheticException = hint && hint.syntheticException || void 0;
  const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
  event.level = level;
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}
function eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {
  let event;
  if (isErrorEvent(exception) && exception.error) {
    const errorEvent = exception;
    return eventFromError(stackParser, errorEvent.error);
  }
  if (isDOMError(exception) || isDOMException(exception)) {
    const domException = exception;
    if ("stack" in exception) {
      event = eventFromError(stackParser, exception);
    } else {
      const name = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
      const message = domException.message ? `${name}: ${domException.message}` : name;
      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
      addExceptionTypeValue(event, message);
    }
    if ("code" in domException) {
      event.tags = { ...event.tags, "DOMException.code": `${domException.code}` };
    }
    return event;
  }
  if (isError(exception)) {
    return eventFromError(stackParser, exception);
  }
  if (isPlainObject(exception) || isEvent(exception)) {
    const objectException = exception;
    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  event = eventFromString(stackParser, exception, syntheticException, attachStacktrace);
  addExceptionTypeValue(event, `${exception}`, void 0);
  addExceptionMechanism(event, {
    synthetic: true
  });
  return event;
}
function eventFromString(stackParser, input, syntheticException, attachStacktrace) {
  const event = {
    message: input
  };
  if (attachStacktrace && syntheticException) {
    const frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      event.exception = {
        values: [{ value: input, stacktrace: { frames } }]
      };
    }
  }
  return event;
}

// node_modules/@sentry/browser/esm/integrations/breadcrumbs.js
var BREADCRUMB_INTEGRATION_ID = "Breadcrumbs";
var Breadcrumbs = class {
  static __initStatic() {
    this.id = BREADCRUMB_INTEGRATION_ID;
  }
  __init() {
    this.name = Breadcrumbs.id;
  }
  constructor(options) {
    ;
    Breadcrumbs.prototype.__init.call(this);
    this.options = {
      console: true,
      dom: true,
      fetch: true,
      history: true,
      sentry: true,
      xhr: true,
      ...options
    };
  }
  setupOnce() {
    if (this.options.console) {
      addInstrumentationHandler("console", _consoleBreadcrumb);
    }
    if (this.options.dom) {
      addInstrumentationHandler("dom", _domBreadcrumb(this.options.dom));
    }
    if (this.options.xhr) {
      addInstrumentationHandler("xhr", _xhrBreadcrumb);
    }
    if (this.options.fetch) {
      addInstrumentationHandler("fetch", _fetchBreadcrumb);
    }
    if (this.options.history) {
      addInstrumentationHandler("history", _historyBreadcrumb);
    }
  }
};
Breadcrumbs.__initStatic();
function _domBreadcrumb(dom) {
  function _innerDomBreadcrumb(handlerData) {
    let target;
    let keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
    if (typeof keyAttrs === "string") {
      keyAttrs = [keyAttrs];
    }
    try {
      target = handlerData.event.target ? htmlTreeAsString(handlerData.event.target, keyAttrs) : htmlTreeAsString(handlerData.event, keyAttrs);
    } catch (e) {
      target = "<unknown>";
    }
    if (target.length === 0) {
      return;
    }
    getCurrentHub().addBreadcrumb({
      category: `ui.${handlerData.name}`,
      message: target
    }, {
      event: handlerData.event,
      name: handlerData.name,
      global: handlerData.global
    });
  }
  return _innerDomBreadcrumb;
}
function _consoleBreadcrumb(handlerData) {
  for (let i = 0; i < handlerData.args.length; i++) {
    if (handlerData.args[i] === "ref=Ref<") {
      handlerData.args[i + 1] = "viewRef";
      break;
    }
  }
  const breadcrumb = {
    category: "console",
    data: {
      arguments: handlerData.args,
      logger: "console"
    },
    level: severityLevelFromString(handlerData.level),
    message: safeJoin(handlerData.args, " ")
  };
  if (handlerData.level === "assert") {
    if (handlerData.args[0] === false) {
      breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), " ") || "console.assert"}`;
      breadcrumb.data.arguments = handlerData.args.slice(1);
    } else {
      return;
    }
  }
  getCurrentHub().addBreadcrumb(breadcrumb, {
    input: handlerData.args,
    level: handlerData.level
  });
}
function _xhrBreadcrumb(handlerData) {
  if (handlerData.endTimestamp) {
    if (handlerData.xhr.__sentry_own_request__) {
      return;
    }
    const { method, url, status_code, body } = handlerData.xhr.__sentry_xhr__ || {};
    getCurrentHub().addBreadcrumb({
      category: "xhr",
      data: {
        method,
        url,
        status_code
      },
      type: "http"
    }, {
      xhr: handlerData.xhr,
      input: body
    });
    return;
  }
}
function _fetchBreadcrumb(handlerData) {
  if (!handlerData.endTimestamp) {
    return;
  }
  if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
    return;
  }
  if (handlerData.error) {
    getCurrentHub().addBreadcrumb({
      category: "fetch",
      data: handlerData.fetchData,
      level: "error",
      type: "http"
    }, {
      data: handlerData.error,
      input: handlerData.args
    });
  } else {
    getCurrentHub().addBreadcrumb({
      category: "fetch",
      data: {
        ...handlerData.fetchData,
        status_code: handlerData.response.status
      },
      type: "http"
    }, {
      input: handlerData.args,
      response: handlerData.response
    });
  }
}
function _historyBreadcrumb(handlerData) {
  let from = handlerData.from;
  let to = handlerData.to;
  const parsedLoc = parseUrl(WINDOW.location.href);
  let parsedFrom = parseUrl(from);
  const parsedTo = parseUrl(to);
  if (!parsedFrom.path) {
    parsedFrom = parsedLoc;
  }
  if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
    to = parsedTo.relative;
  }
  if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
    from = parsedFrom.relative;
  }
  getCurrentHub().addBreadcrumb({
    category: "navigation",
    data: {
      from,
      to
    }
  });
}

// node_modules/@sentry/browser/esm/client.js
var BrowserClient = class extends BaseClient {
  constructor(options) {
    options._metadata = options._metadata || {};
    options._metadata.sdk = options._metadata.sdk || {
      name: "sentry.javascript.browser",
      packages: [
        {
          name: "npm:@sentry/browser",
          version: SDK_VERSION
        }
      ],
      version: SDK_VERSION
    };
    super(options);
    if (options.sendClientReports && WINDOW.document) {
      WINDOW.document.addEventListener("visibilitychange", () => {
        if (WINDOW.document.visibilityState === "hidden") {
          this._flushOutcomes();
        }
      });
    }
  }
  eventFromException(exception, hint) {
    return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
  }
  eventFromMessage(message, level = "info", hint) {
    return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
  }
  sendEvent(event, hint) {
    const breadcrumbIntegration = this.getIntegrationById(BREADCRUMB_INTEGRATION_ID);
    if (breadcrumbIntegration && breadcrumbIntegration.options && breadcrumbIntegration.options.sentry) {
      getCurrentHub().addBreadcrumb({
        category: `sentry.${event.type === "transaction" ? "transaction" : "event"}`,
        event_id: event.event_id,
        level: event.level,
        message: getEventDescription(event)
      }, {
        event
      });
    }
    super.sendEvent(event, hint);
  }
  _prepareEvent(event, hint, scope) {
    event.platform = event.platform || "javascript";
    return super._prepareEvent(event, hint, scope);
  }
  _flushOutcomes() {
    const outcomes = this._clearOutcomes();
    if (outcomes.length === 0) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("No dsn provided, will not send outcomes");
      return;
    }
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("Sending outcomes:", outcomes);
    const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, this._options);
    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
    try {
      const isRealNavigator = Object.prototype.toString.call(WINDOW && WINDOW.navigator) === "[object Navigator]";
      const hasSendBeacon = isRealNavigator && typeof WINDOW.navigator.sendBeacon === "function";
      if (hasSendBeacon && !this._options.transportOptions) {
        const sendBeacon = WINDOW.navigator.sendBeacon.bind(WINDOW.navigator);
        sendBeacon(url, serializeEnvelope(envelope));
      } else {
        this._sendEnvelope(envelope);
      }
    } catch (e) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.error(e);
    }
  }
};

// node_modules/@sentry/browser/esm/transports/utils.js
var cachedFetchImpl = void 0;
function getNativeFetchImplementation() {
  if (cachedFetchImpl) {
    return cachedFetchImpl;
  }
  if (isNativeFetch(WINDOW.fetch)) {
    return cachedFetchImpl = WINDOW.fetch.bind(WINDOW);
  }
  const document = WINDOW.document;
  let fetchImpl = WINDOW.fetch;
  if (document && typeof document.createElement === "function") {
    try {
      const sandbox = document.createElement("iframe");
      sandbox.hidden = true;
      document.head.appendChild(sandbox);
      const contentWindow = sandbox.contentWindow;
      if (contentWindow && contentWindow.fetch) {
        fetchImpl = contentWindow.fetch;
      }
      document.head.removeChild(sandbox);
    } catch (e) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e);
    }
  }
  return cachedFetchImpl = fetchImpl.bind(WINDOW);
}
function clearCachedFetchImplementation() {
  cachedFetchImpl = void 0;
}

// node_modules/@sentry/browser/esm/transports/fetch.js
function makeFetchTransport(options, nativeFetch = getNativeFetchImplementation()) {
  function makeRequest(request) {
    const requestOptions = {
      body: request.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: options.headers,
      keepalive: request.body.length <= 65536,
      ...options.fetchOptions
    };
    try {
      return nativeFetch(options.url, requestOptions).then((response) => ({
        statusCode: response.status,
        headers: {
          "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": response.headers.get("Retry-After")
        }
      }));
    } catch (e) {
      clearCachedFetchImplementation();
      return rejectedSyncPromise(e);
    }
  }
  return createTransport(options, makeRequest);
}

// node_modules/@sentry/browser/esm/transports/xhr.js
var XHR_READYSTATE_DONE = 4;
function makeXHRTransport(options) {
  function makeRequest(request) {
    return new SyncPromise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.onerror = reject;
      xhr.onreadystatechange = () => {
        if (xhr.readyState === XHR_READYSTATE_DONE) {
          resolve({
            statusCode: xhr.status,
            headers: {
              "x-sentry-rate-limits": xhr.getResponseHeader("X-Sentry-Rate-Limits"),
              "retry-after": xhr.getResponseHeader("Retry-After")
            }
          });
        }
      };
      xhr.open("POST", options.url);
      for (const header in options.headers) {
        if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
          xhr.setRequestHeader(header, options.headers[header]);
        }
      }
      xhr.send(request.body);
    });
  }
  return createTransport(options, makeRequest);
}

// node_modules/@sentry/browser/esm/stack-parsers.js
var UNKNOWN_FUNCTION = "?";
var OPERA10_PRIORITY = 10;
var OPERA11_PRIORITY = 20;
var CHROME_PRIORITY = 30;
var WINJS_PRIORITY = 40;
var GECKO_PRIORITY = 50;
function createFrame(filename, func, lineno, colno) {
  const frame = {
    filename,
    function: func,
    in_app: true
  };
  if (lineno !== void 0) {
    frame.lineno = lineno;
  }
  if (colno !== void 0) {
    frame.colno = colno;
  }
  return frame;
}
var chromeRegex = /^\s*at (?:(.*\).*?|.*?) ?\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
var chrome = (line) => {
  const parts = chromeRegex.exec(line);
  if (parts) {
    const isEval = parts[2] && parts[2].indexOf("eval") === 0;
    if (isEval) {
      const subMatch = chromeEvalRegex.exec(parts[2]);
      if (subMatch) {
        parts[2] = subMatch[1];
        parts[3] = subMatch[2];
        parts[4] = subMatch[3];
      }
    }
    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);
    return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
  }
  return;
};
var chromeStackLineParser = [CHROME_PRIORITY, chrome];
var geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|safari-extension|safari-web-extension|capacitor)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
var gecko = (line) => {
  const parts = geckoREgex.exec(line);
  if (parts) {
    const isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
    if (isEval) {
      const subMatch = geckoEvalRegex.exec(parts[3]);
      if (subMatch) {
        parts[1] = parts[1] || "eval";
        parts[3] = subMatch[1];
        parts[4] = subMatch[2];
        parts[5] = "";
      }
    }
    let filename = parts[3];
    let func = parts[1] || UNKNOWN_FUNCTION;
    [func, filename] = extractSafariExtensionDetails(func, filename);
    return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
  }
  return;
};
var geckoStackLineParser = [GECKO_PRIORITY, gecko];
var winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
var winjs = (line) => {
  const parts = winjsRegex.exec(line);
  return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : void 0) : void 0;
};
var winjsStackLineParser = [WINJS_PRIORITY, winjs];
var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;
var opera10 = (line) => {
  const parts = opera10Regex.exec(line);
  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : void 0;
};
var opera10StackLineParser = [OPERA10_PRIORITY, opera10];
var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i;
var opera11 = (line) => {
  const parts = opera11Regex.exec(line);
  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : void 0;
};
var opera11StackLineParser = [OPERA11_PRIORITY, opera11];
var defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];
var defaultStackParser = createStackParser(...defaultStackLineParsers);
var extractSafariExtensionDetails = (func, filename) => {
  const isSafariExtension = func.indexOf("safari-extension") !== -1;
  const isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
  return isSafariExtension || isSafariWebExtension ? [
    func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
    isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`
  ] : [func, filename];
};

// node_modules/@sentry/browser/esm/integrations/index.js
var integrations_exports2 = {};
__export(integrations_exports2, {
  Breadcrumbs: () => Breadcrumbs,
  Dedupe: () => Dedupe,
  GlobalHandlers: () => GlobalHandlers,
  HttpContext: () => HttpContext,
  LinkedErrors: () => LinkedErrors,
  TryCatch: () => TryCatch
});

// node_modules/@sentry/browser/esm/integrations/globalhandlers.js
var GlobalHandlers = class {
  static __initStatic() {
    this.id = "GlobalHandlers";
  }
  __init() {
    this.name = GlobalHandlers.id;
  }
  __init2() {
    this._installFunc = {
      onerror: _installGlobalOnErrorHandler,
      onunhandledrejection: _installGlobalOnUnhandledRejectionHandler
    };
  }
  constructor(options) {
    ;
    GlobalHandlers.prototype.__init.call(this);
    GlobalHandlers.prototype.__init2.call(this);
    this._options = {
      onerror: true,
      onunhandledrejection: true,
      ...options
    };
  }
  setupOnce() {
    Error.stackTraceLimit = 50;
    const options = this._options;
    for (const key in options) {
      const installFunc = this._installFunc[key];
      if (installFunc && options[key]) {
        globalHandlerLog(key);
        installFunc();
        this._installFunc[key] = void 0;
      }
    }
  }
};
GlobalHandlers.__initStatic();
function _installGlobalOnErrorHandler() {
  addInstrumentationHandler("error", (data) => {
    const [hub, stackParser, attachStacktrace] = getHubAndOptions();
    if (!hub.getIntegration(GlobalHandlers)) {
      return;
    }
    const { msg, url, line, column, error } = data;
    if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {
      return;
    }
    const event = error === void 0 && isString(msg) ? _eventFromIncompleteOnError(msg, url, line, column) : _enhanceEventWithInitialFrame(eventFromUnknownInput(stackParser, error || msg, void 0, attachStacktrace, false), url, line, column);
    event.level = "error";
    addMechanismAndCapture(hub, error, event, "onerror");
  });
}
function _installGlobalOnUnhandledRejectionHandler() {
  addInstrumentationHandler("unhandledrejection", (e) => {
    const [hub, stackParser, attachStacktrace] = getHubAndOptions();
    if (!hub.getIntegration(GlobalHandlers)) {
      return;
    }
    let error = e;
    try {
      if ("reason" in e) {
        error = e.reason;
      } else if ("detail" in e && "reason" in e.detail) {
        error = e.detail.reason;
      }
    } catch (_oO) {
    }
    if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {
      return true;
    }
    const event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(stackParser, error, void 0, attachStacktrace, true);
    event.level = "error";
    addMechanismAndCapture(hub, error, event, "onunhandledrejection");
    return;
  });
}
function _eventFromRejectionWithPrimitive(reason) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          value: `Non-Error promise rejection captured with value: ${String(reason)}`
        }
      ]
    }
  };
}
function _eventFromIncompleteOnError(msg, url, line, column) {
  const ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
  let message = isErrorEvent(msg) ? msg.message : msg;
  let name = "Error";
  const groups = message.match(ERROR_TYPES_RE);
  if (groups) {
    name = groups[1];
    message = groups[2];
  }
  const event = {
    exception: {
      values: [
        {
          type: name,
          value: message
        }
      ]
    }
  };
  return _enhanceEventWithInitialFrame(event, url, line, column);
}
function _enhanceEventWithInitialFrame(event, url, line, column) {
  const e = event.exception = event.exception || {};
  const ev = e.values = e.values || [];
  const ev0 = ev[0] = ev[0] || {};
  const ev0s = ev0.stacktrace = ev0.stacktrace || {};
  const ev0sf = ev0s.frames = ev0s.frames || [];
  const colno = isNaN(parseInt(column, 10)) ? void 0 : column;
  const lineno = isNaN(parseInt(line, 10)) ? void 0 : line;
  const filename = isString(url) && url.length > 0 ? url : getLocationHref();
  if (ev0sf.length === 0) {
    ev0sf.push({
      colno,
      filename,
      function: "?",
      in_app: true,
      lineno
    });
  }
  return event;
}
function globalHandlerLog(type) {
  (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`Global Handler attached: ${type}`);
}
function addMechanismAndCapture(hub, error, event, type) {
  addExceptionMechanism(event, {
    handled: false,
    type
  });
  hub.captureEvent(event, {
    originalException: error
  });
}
function getHubAndOptions() {
  const hub = getCurrentHub();
  const client = hub.getClient();
  const options = client && client.getOptions() || {
    stackParser: () => [],
    attachStacktrace: false
  };
  return [hub, options.stackParser, options.attachStacktrace];
}

// node_modules/@sentry/browser/esm/integrations/trycatch.js
var DEFAULT_EVENT_TARGET = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
];
var TryCatch = class {
  static __initStatic() {
    this.id = "TryCatch";
  }
  __init() {
    this.name = TryCatch.id;
  }
  constructor(options) {
    ;
    TryCatch.prototype.__init.call(this);
    this._options = {
      XMLHttpRequest: true,
      eventTarget: true,
      requestAnimationFrame: true,
      setInterval: true,
      setTimeout: true,
      ...options
    };
  }
  setupOnce() {
    if (this._options.setTimeout) {
      fill(WINDOW, "setTimeout", _wrapTimeFunction);
    }
    if (this._options.setInterval) {
      fill(WINDOW, "setInterval", _wrapTimeFunction);
    }
    if (this._options.requestAnimationFrame) {
      fill(WINDOW, "requestAnimationFrame", _wrapRAF);
    }
    if (this._options.XMLHttpRequest && "XMLHttpRequest" in WINDOW) {
      fill(XMLHttpRequest.prototype, "send", _wrapXHR);
    }
    const eventTargetOption = this._options.eventTarget;
    if (eventTargetOption) {
      const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
      eventTarget.forEach(_wrapEventTarget);
    }
  }
};
TryCatch.__initStatic();
function _wrapTimeFunction(original) {
  return function(...args) {
    const originalCallback = args[0];
    args[0] = wrap(originalCallback, {
      mechanism: {
        data: { function: getFunctionName(original) },
        handled: true,
        type: "instrument"
      }
    });
    return original.apply(this, args);
  };
}
function _wrapRAF(original) {
  return function(callback) {
    return original.apply(this, [
      wrap(callback, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: getFunctionName(original)
          },
          handled: true,
          type: "instrument"
        }
      })
    ]);
  };
}
function _wrapXHR(originalSend) {
  return function(...args) {
    const xhr = this;
    const xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
    xmlHttpRequestProps.forEach((prop) => {
      if (prop in xhr && typeof xhr[prop] === "function") {
        fill(xhr, prop, function(original) {
          const wrapOptions = {
            mechanism: {
              data: {
                function: prop,
                handler: getFunctionName(original)
              },
              handled: true,
              type: "instrument"
            }
          };
          const originalFunction = getOriginalFunction(original);
          if (originalFunction) {
            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
          }
          return wrap(original, wrapOptions);
        });
      }
    });
    return originalSend.apply(this, args);
  };
}
function _wrapEventTarget(target) {
  const globalObject = WINDOW;
  const proto = globalObject[target] && globalObject[target].prototype;
  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
    return;
  }
  fill(proto, "addEventListener", function(original) {
    return function(eventName, fn, options) {
      try {
        if (typeof fn.handleEvent === "function") {
          fn.handleEvent = wrap(fn.handleEvent, {
            mechanism: {
              data: {
                function: "handleEvent",
                handler: getFunctionName(fn),
                target
              },
              handled: true,
              type: "instrument"
            }
          });
        }
      } catch (err) {
      }
      return original.apply(this, [
        eventName,
        wrap(fn, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: getFunctionName(fn),
              target
            },
            handled: true,
            type: "instrument"
          }
        }),
        options
      ]);
    };
  });
  fill(proto, "removeEventListener", function(originalRemoveEventListener) {
    return function(eventName, fn, options) {
      const wrappedEventHandler = fn;
      try {
        const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
        if (originalEventHandler) {
          originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
        }
      } catch (e) {
      }
      return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
    };
  });
}

// node_modules/@sentry/browser/esm/integrations/linkederrors.js
var DEFAULT_KEY = "cause";
var DEFAULT_LIMIT = 5;
var LinkedErrors = class {
  static __initStatic() {
    this.id = "LinkedErrors";
  }
  __init() {
    this.name = LinkedErrors.id;
  }
  constructor(options = {}) {
    ;
    LinkedErrors.prototype.__init.call(this);
    this._key = options.key || DEFAULT_KEY;
    this._limit = options.limit || DEFAULT_LIMIT;
  }
  setupOnce() {
    const client = getCurrentHub().getClient();
    if (!client) {
      return;
    }
    addGlobalEventProcessor((event, hint) => {
      const self = getCurrentHub().getIntegration(LinkedErrors);
      return self ? _handler(client.getOptions().stackParser, self._key, self._limit, event, hint) : event;
    });
  }
};
LinkedErrors.__initStatic();
function _handler(parser, key, limit, event, hint) {
  if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
    return event;
  }
  const linkedErrors = _walkErrorTree(parser, limit, hint.originalException, key);
  event.exception.values = [...linkedErrors, ...event.exception.values];
  return event;
}
function _walkErrorTree(parser, limit, error, key, stack = []) {
  if (!isInstanceOf(error[key], Error) || stack.length + 1 >= limit) {
    return stack;
  }
  const exception = exceptionFromError(parser, error[key]);
  return _walkErrorTree(parser, limit, error[key], key, [exception, ...stack]);
}

// node_modules/@sentry/browser/esm/integrations/httpcontext.js
var HttpContext = class {
  constructor() {
    HttpContext.prototype.__init.call(this);
  }
  static __initStatic() {
    this.id = "HttpContext";
  }
  __init() {
    this.name = HttpContext.id;
  }
  setupOnce() {
    addGlobalEventProcessor((event) => {
      if (getCurrentHub().getIntegration(HttpContext)) {
        if (!WINDOW.navigator && !WINDOW.location && !WINDOW.document) {
          return event;
        }
        const url = event.request && event.request.url || WINDOW.location && WINDOW.location.href;
        const { referrer } = WINDOW.document || {};
        const { userAgent } = WINDOW.navigator || {};
        const headers = {
          ...event.request && event.request.headers,
          ...referrer && { Referer: referrer },
          ...userAgent && { "User-Agent": userAgent }
        };
        const request = { ...url && { url }, headers };
        return { ...event, request };
      }
      return event;
    });
  }
};
HttpContext.__initStatic();

// node_modules/@sentry/browser/esm/integrations/dedupe.js
var Dedupe = class {
  constructor() {
    Dedupe.prototype.__init.call(this);
  }
  static __initStatic() {
    this.id = "Dedupe";
  }
  __init() {
    this.name = Dedupe.id;
  }
  setupOnce(addGlobalEventProcessor2, getCurrentHub2) {
    const eventProcessor = (currentEvent) => {
      const self = getCurrentHub2().getIntegration(Dedupe);
      if (self) {
        try {
          if (_shouldDropEvent(currentEvent, self._previousEvent)) {
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("Event dropped due to being a duplicate of previously captured event.");
            return null;
          }
        } catch (_oO) {
          return self._previousEvent = currentEvent;
        }
        return self._previousEvent = currentEvent;
      }
      return currentEvent;
    };
    eventProcessor.id = this.name;
    addGlobalEventProcessor2(eventProcessor);
  }
};
Dedupe.__initStatic();
function _shouldDropEvent(currentEvent, previousEvent) {
  if (!previousEvent) {
    return false;
  }
  if (_isSameMessageEvent(currentEvent, previousEvent)) {
    return true;
  }
  if (_isSameExceptionEvent(currentEvent, previousEvent)) {
    return true;
  }
  return false;
}
function _isSameMessageEvent(currentEvent, previousEvent) {
  const currentMessage = currentEvent.message;
  const previousMessage = previousEvent.message;
  if (!currentMessage && !previousMessage) {
    return false;
  }
  if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
    return false;
  }
  if (currentMessage !== previousMessage) {
    return false;
  }
  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }
  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }
  return true;
}
function _isSameExceptionEvent(currentEvent, previousEvent) {
  const previousException = _getExceptionFromEvent(previousEvent);
  const currentException = _getExceptionFromEvent(currentEvent);
  if (!previousException || !currentException) {
    return false;
  }
  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
    return false;
  }
  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }
  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }
  return true;
}
function _isSameStacktrace(currentEvent, previousEvent) {
  let currentFrames = _getFramesFromEvent(currentEvent);
  let previousFrames = _getFramesFromEvent(previousEvent);
  if (!currentFrames && !previousFrames) {
    return true;
  }
  if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
    return false;
  }
  currentFrames = currentFrames;
  previousFrames = previousFrames;
  if (previousFrames.length !== currentFrames.length) {
    return false;
  }
  for (let i = 0; i < previousFrames.length; i++) {
    const frameA = previousFrames[i];
    const frameB = currentFrames[i];
    if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
      return false;
    }
  }
  return true;
}
function _isSameFingerprint(currentEvent, previousEvent) {
  let currentFingerprint = currentEvent.fingerprint;
  let previousFingerprint = previousEvent.fingerprint;
  if (!currentFingerprint && !previousFingerprint) {
    return true;
  }
  if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
    return false;
  }
  currentFingerprint = currentFingerprint;
  previousFingerprint = previousFingerprint;
  try {
    return !!(currentFingerprint.join("") === previousFingerprint.join(""));
  } catch (_oO) {
    return false;
  }
}
function _getExceptionFromEvent(event) {
  return event.exception && event.exception.values && event.exception.values[0];
}
function _getFramesFromEvent(event) {
  const exception = event.exception;
  if (exception) {
    try {
      return exception.values[0].stacktrace.frames;
    } catch (_oO) {
      return void 0;
    }
  }
  return void 0;
}

// node_modules/@sentry/browser/esm/sdk.js
var defaultIntegrations = [
  new integrations_exports.InboundFilters(),
  new integrations_exports.FunctionToString(),
  new TryCatch(),
  new Breadcrumbs(),
  new GlobalHandlers(),
  new LinkedErrors(),
  new Dedupe(),
  new HttpContext()
];
function init(options = {}) {
  if (options.defaultIntegrations === void 0) {
    options.defaultIntegrations = defaultIntegrations;
  }
  if (options.release === void 0) {
    if (WINDOW.SENTRY_RELEASE && WINDOW.SENTRY_RELEASE.id) {
      options.release = WINDOW.SENTRY_RELEASE.id;
    }
  }
  if (options.autoSessionTracking === void 0) {
    options.autoSessionTracking = true;
  }
  if (options.sendClientReports === void 0) {
    options.sendClientReports = true;
  }
  const clientOptions = {
    ...options,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup(options),
    transport: options.transport || (supportsFetch() ? makeFetchTransport : makeXHRTransport)
  };
  initAndBind(BrowserClient, clientOptions);
  if (options.autoSessionTracking) {
    startSessionTracking();
  }
}
function showReportDialog(options = {}, hub = getCurrentHub()) {
  if (!WINDOW.document) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.error("Global document not defined in showReportDialog call");
    return;
  }
  const { client, scope } = hub.getStackTop();
  const dsn = options.dsn || client && client.getDsn();
  if (!dsn) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.error("DSN not configured for showReportDialog call");
    return;
  }
  if (scope) {
    options.user = {
      ...scope.getUser(),
      ...options.user
    };
  }
  if (!options.eventId) {
    options.eventId = hub.lastEventId();
  }
  const script = WINDOW.document.createElement("script");
  script.async = true;
  script.src = getReportDialogEndpoint(dsn, options);
  if (options.onLoad) {
    script.onload = options.onLoad;
  }
  const injectionPoint = WINDOW.document.head || WINDOW.document.body;
  if (injectionPoint) {
    injectionPoint.appendChild(script);
  } else {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.error("Not injecting report dialog. No injection point found in HTML");
  }
}
function lastEventId() {
  return getCurrentHub().lastEventId();
}
function forceLoad() {
}
function onLoad(callback) {
  callback();
}
function flush(timeout) {
  const client = getCurrentHub().getClient();
  if (client) {
    return client.flush(timeout);
  }
  (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("Cannot flush events. No client defined.");
  return resolvedSyncPromise(false);
}
function close(timeout) {
  const client = getCurrentHub().getClient();
  if (client) {
    return client.close(timeout);
  }
  (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("Cannot flush events and disable SDK. No client defined.");
  return resolvedSyncPromise(false);
}
function wrap2(fn) {
  return wrap(fn)();
}
function startSessionOnHub(hub) {
  hub.startSession({ ignoreDuration: true });
  hub.captureSession();
}
function startSessionTracking() {
  if (typeof WINDOW.document === "undefined") {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return;
  }
  const hub = getCurrentHub();
  if (!hub.captureSession) {
    return;
  }
  startSessionOnHub(hub);
  addInstrumentationHandler("history", ({ from, to }) => {
    if (!(from === void 0 || from === to)) {
      startSessionOnHub(getCurrentHub());
    }
  });
}

// node_modules/@sentry/browser/esm/index.js
var windowIntegrations = {};
if (WINDOW.Sentry && WINDOW.Sentry.Integrations) {
  windowIntegrations = WINDOW.Sentry.Integrations;
}
var INTEGRATIONS = {
  ...windowIntegrations,
  ...integrations_exports,
  ...integrations_exports2
};

// node_modules/@sentry/react/esm/sdk.js
function init2(options) {
  options._metadata = options._metadata || {};
  options._metadata.sdk = options._metadata.sdk || {
    name: "sentry.javascript.react",
    packages: [
      {
        name: "npm:@sentry/react",
        version: SDK_VERSION
      }
    ],
    version: SDK_VERSION
  };
  init(options);
}

// node_modules/@sentry/react/esm/profiler.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var React = __toESM(require_react());

// node_modules/@sentry/react/esm/constants.js
var REACT_RENDER_OP = "ui.react.render";
var REACT_UPDATE_OP = "ui.react.update";
var REACT_MOUNT_OP = "ui.react.mount";

// node_modules/@sentry/react/esm/profiler.js
var _jsxFileName = "/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/profiler.tsx";
var UNKNOWN_COMPONENT = "unknown";
var Profiler = class extends React.Component {
  __init() {
    this._mountSpan = void 0;
  }
  __init2() {
    this._updateSpan = void 0;
  }
  static __initStatic() {
    this.defaultProps = {
      disabled: false,
      includeRender: true,
      includeUpdates: true
    };
  }
  constructor(props) {
    super(props);
    Profiler.prototype.__init.call(this);
    Profiler.prototype.__init2.call(this);
    ;
    const { name, disabled = false } = this.props;
    if (disabled) {
      return;
    }
    const activeTransaction3 = getActiveTransaction();
    if (activeTransaction3) {
      this._mountSpan = activeTransaction3.startChild({
        description: `<${name}>`,
        op: REACT_MOUNT_OP
      });
    }
  }
  componentDidMount() {
    if (this._mountSpan) {
      this._mountSpan.finish();
    }
  }
  shouldComponentUpdate({ updateProps, includeUpdates = true }) {
    if (includeUpdates && this._mountSpan && updateProps !== this.props.updateProps) {
      const changedProps = Object.keys(updateProps).filter((k) => updateProps[k] !== this.props.updateProps[k]);
      if (changedProps.length > 0) {
        const now = timestampWithMs();
        this._updateSpan = this._mountSpan.startChild({
          data: {
            changedProps
          },
          description: `<${this.props.name}>`,
          op: REACT_UPDATE_OP,
          startTimestamp: now
        });
      }
    }
    return true;
  }
  componentDidUpdate() {
    if (this._updateSpan) {
      this._updateSpan.finish();
      this._updateSpan = void 0;
    }
  }
  componentWillUnmount() {
    const { name, includeRender = true } = this.props;
    if (this._mountSpan && includeRender) {
      this._mountSpan.startChild({
        description: `<${name}>`,
        endTimestamp: timestampWithMs(),
        op: REACT_RENDER_OP,
        startTimestamp: this._mountSpan.endTimestamp
      });
    }
  }
  render() {
    return this.props.children;
  }
};
Profiler.__initStatic();
function withProfiler(WrappedComponent, options) {
  const componentDisplayName = options && options.name || WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;
  const Wrapped = (props) => React.createElement(Profiler, { ...options, name: componentDisplayName, updateProps: props, __self: this, __source: { fileName: _jsxFileName, lineNumber: 143 } }, React.createElement(WrappedComponent, { ...props, __self: this, __source: { fileName: _jsxFileName, lineNumber: 144 } }));
  Wrapped.displayName = `profiler(${componentDisplayName})`;
  (0, import_hoist_non_react_statics.default)(Wrapped, WrappedComponent);
  return Wrapped;
}
function useProfiler(name, options = {
  disabled: false,
  hasRenderSpan: true
}) {
  const [mountSpan] = React.useState(() => {
    if (options && options.disabled) {
      return void 0;
    }
    const activeTransaction3 = getActiveTransaction();
    if (activeTransaction3) {
      return activeTransaction3.startChild({
        description: `<${name}>`,
        op: REACT_MOUNT_OP
      });
    }
    return void 0;
  });
  React.useEffect(() => {
    if (mountSpan) {
      mountSpan.finish();
    }
    return () => {
      if (mountSpan && options.hasRenderSpan) {
        mountSpan.startChild({
          description: `<${name}>`,
          endTimestamp: timestampWithMs(),
          op: REACT_RENDER_OP,
          startTimestamp: mountSpan.endTimestamp
        });
      }
    };
  }, []);
}
function getActiveTransaction(hub = getCurrentHub()) {
  if (hub) {
    const scope = hub.getScope();
    if (scope) {
      return scope.getTransaction();
    }
  }
  return void 0;
}

// node_modules/@sentry/react/esm/errorboundary.js
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
var React2 = __toESM(require_react());
var _jsxFileName2 = "/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/errorboundary.tsx";
function isAtLeastReact17(version2) {
  const major = version2.match(/^([^.]+)/);
  return major !== null && parseInt(major[0]) >= 17;
}
var UNKNOWN_COMPONENT2 = "unknown";
var INITIAL_STATE = {
  componentStack: null,
  error: null,
  eventId: null
};
var ErrorBoundary = class extends React2.Component {
  constructor(...args) {
    super(...args);
    ErrorBoundary.prototype.__init.call(this);
    ErrorBoundary.prototype.__init2.call(this);
  }
  __init() {
    this.state = INITIAL_STATE;
  }
  componentDidCatch(error, { componentStack }) {
    const { beforeCapture, onError, showDialog, dialogOptions } = this.props;
    withScope((scope) => {
      if (isAtLeastReact17(React2.version)) {
        const errorBoundaryError = new Error(error.message);
        errorBoundaryError.name = `React ErrorBoundary ${errorBoundaryError.name}`;
        errorBoundaryError.stack = componentStack;
        error.cause = errorBoundaryError;
      }
      if (beforeCapture) {
        beforeCapture(scope, error, componentStack);
      }
      const eventId = captureException(error, { contexts: { react: { componentStack } } });
      if (onError) {
        onError(error, componentStack, eventId);
      }
      if (showDialog) {
        showReportDialog({ ...dialogOptions, eventId });
      }
      this.setState({ error, componentStack, eventId });
    });
  }
  componentDidMount() {
    const { onMount } = this.props;
    if (onMount) {
      onMount();
    }
  }
  componentWillUnmount() {
    const { error, componentStack, eventId } = this.state;
    const { onUnmount } = this.props;
    if (onUnmount) {
      onUnmount(error, componentStack, eventId);
    }
  }
  __init2() {
    this.resetErrorBoundary = () => {
      const { onReset } = this.props;
      const { error, componentStack, eventId } = this.state;
      if (onReset) {
        onReset(error, componentStack, eventId);
      }
      this.setState(INITIAL_STATE);
    };
  }
  render() {
    const { fallback, children } = this.props;
    const { error, componentStack, eventId } = this.state;
    if (error) {
      let element = void 0;
      if (typeof fallback === "function") {
        element = fallback({ error, componentStack, resetError: this.resetErrorBoundary, eventId });
      } else {
        element = fallback;
      }
      if (React2.isValidElement(element)) {
        return element;
      }
      if (fallback) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("fallback did not produce a valid ReactElement");
      }
      return null;
    }
    if (typeof children === "function") {
      return children();
    }
    return children;
  }
};
function withErrorBoundary(WrappedComponent, errorBoundaryOptions) {
  const componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT2;
  const Wrapped = (props) => React2.createElement(ErrorBoundary, { ...errorBoundaryOptions, __self: this, __source: { fileName: _jsxFileName2, lineNumber: 168 } }, React2.createElement(WrappedComponent, { ...props, __self: this, __source: { fileName: _jsxFileName2, lineNumber: 169 } }));
  Wrapped.displayName = `errorBoundary(${componentDisplayName})`;
  (0, import_hoist_non_react_statics2.default)(Wrapped, WrappedComponent);
  return Wrapped;
}

// node_modules/@sentry/react/esm/redux.js
var ACTION_BREADCRUMB_CATEGORY = "redux.action";
var ACTION_BREADCRUMB_TYPE = "info";
var defaultOptions = {
  actionTransformer: (action) => action,
  stateTransformer: (state) => state || null
};
function createReduxEnhancer(enhancerOptions) {
  const options = {
    ...defaultOptions,
    ...enhancerOptions
  };
  return (next) => (reducer, initialState) => {
    const sentryReducer = (state, action) => {
      const newState = reducer(state, action);
      configureScope((scope) => {
        const transformedAction = options.actionTransformer(action);
        if (typeof transformedAction !== "undefined" && transformedAction !== null) {
          scope.addBreadcrumb({
            category: ACTION_BREADCRUMB_CATEGORY,
            data: transformedAction,
            type: ACTION_BREADCRUMB_TYPE
          });
        }
        const transformedState = options.stateTransformer(newState);
        if (typeof transformedState !== "undefined" && transformedState !== null) {
          scope.setContext("state", { state: { type: "redux", value: transformedState } });
        } else {
          scope.setContext("state", null);
        }
        const { configureScopeWithState } = options;
        if (typeof configureScopeWithState === "function") {
          configureScopeWithState(scope, newState);
        }
      });
      return newState;
    };
    return next(sentryReducer, initialState);
  };
}

// node_modules/@sentry/react/esm/reactrouterv3.js
function reactRouterV3Instrumentation(history, routes, match) {
  return (startTransaction2, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) => {
    let activeTransaction3;
    let prevName;
    if (startTransactionOnPageLoad && WINDOW && WINDOW.location) {
      normalizeTransactionName(routes, WINDOW.location, match, (localName, source = "url") => {
        prevName = localName;
        activeTransaction3 = startTransaction2({
          name: prevName,
          op: "pageload",
          tags: {
            "routing.instrumentation": "react-router-v3"
          },
          metadata: {
            source
          }
        });
      });
    }
    if (startTransactionOnLocationChange && history.listen) {
      history.listen((location) => {
        if (location.action === "PUSH" || location.action === "POP") {
          if (activeTransaction3) {
            activeTransaction3.finish();
          }
          const tags = {
            "routing.instrumentation": "react-router-v3"
          };
          if (prevName) {
            tags.from = prevName;
          }
          normalizeTransactionName(routes, location, match, (localName, source = "url") => {
            prevName = localName;
            activeTransaction3 = startTransaction2({
              name: prevName,
              op: "navigation",
              tags,
              metadata: {
                source
              }
            });
          });
        }
      });
    }
  };
}
function normalizeTransactionName(appRoutes, location, match, callback) {
  let name = location.pathname;
  match({
    location,
    routes: appRoutes
  }, (error, _redirectLocation, renderProps) => {
    if (error || !renderProps) {
      return callback(name);
    }
    const routePath = getRouteStringFromRoutes(renderProps.routes || []);
    if (routePath.length === 0 || routePath === "/*") {
      return callback(name);
    }
    name = routePath;
    return callback(name, "route");
  });
}
function getRouteStringFromRoutes(routes) {
  if (!Array.isArray(routes) || routes.length === 0) {
    return "";
  }
  const routesWithPaths = routes.filter((route) => !!route.path);
  let index = -1;
  for (let x = routesWithPaths.length - 1; x >= 0; x--) {
    const route = routesWithPaths[x];
    if (route.path && route.path.startsWith("/")) {
      index = x;
      break;
    }
  }
  return routesWithPaths.slice(index).filter(({ path }) => !!path).map(({ path }) => path).join("");
}

// node_modules/@sentry/react/esm/reactrouter.js
var import_hoist_non_react_statics3 = __toESM(require_hoist_non_react_statics_cjs());
var React3 = __toESM(require_react());
var _jsxFileName3 = "/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/reactrouter.tsx";
var activeTransaction;
function reactRouterV4Instrumentation(history, routes, matchPath) {
  return createReactRouterInstrumentation(history, "react-router-v4", routes, matchPath);
}
function reactRouterV5Instrumentation(history, routes, matchPath) {
  return createReactRouterInstrumentation(history, "react-router-v5", routes, matchPath);
}
function createReactRouterInstrumentation(history, name, allRoutes = [], matchPath) {
  function getInitPathName() {
    if (history && history.location) {
      return history.location.pathname;
    }
    if (WINDOW && WINDOW.location) {
      return WINDOW.location.pathname;
    }
    return void 0;
  }
  function normalizeTransactionName2(pathname) {
    if (allRoutes.length === 0 || !matchPath) {
      return [pathname, "url"];
    }
    const branches = matchRoutes(allRoutes, pathname, matchPath);
    for (let x = 0; x < branches.length; x++) {
      if (branches[x].match.isExact) {
        return [branches[x].match.path, "route"];
      }
    }
    return [pathname, "url"];
  }
  const tags = {
    "routing.instrumentation": name
  };
  return (customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) => {
    const initPathName = getInitPathName();
    if (startTransactionOnPageLoad && initPathName) {
      const [name2, source] = normalizeTransactionName2(initPathName);
      activeTransaction = customStartTransaction({
        name: name2,
        op: "pageload",
        tags,
        metadata: {
          source
        }
      });
    }
    if (startTransactionOnLocationChange && history.listen) {
      history.listen((location, action) => {
        if (action && (action === "PUSH" || action === "POP")) {
          if (activeTransaction) {
            activeTransaction.finish();
          }
          const [name2, source] = normalizeTransactionName2(location.pathname);
          activeTransaction = customStartTransaction({
            name: name2,
            op: "navigation",
            tags,
            metadata: {
              source
            }
          });
        }
      });
    }
  };
}
function matchRoutes(routes, pathname, matchPath, branch = []) {
  routes.some((route) => {
    const match = route.path ? matchPath(pathname, route) : branch.length ? branch[branch.length - 1].match : computeRootMatch(pathname);
    if (match) {
      branch.push({ route, match });
      if (route.routes) {
        matchRoutes(route.routes, pathname, matchPath, branch);
      }
    }
    return !!match;
  });
  return branch;
}
function computeRootMatch(pathname) {
  return { path: "/", url: "/", params: {}, isExact: pathname === "/" };
}
function withSentryRouting(Route) {
  const componentDisplayName = Route.displayName || Route.name;
  const WrappedRoute = (props) => {
    if (activeTransaction && props && props.computedMatch && props.computedMatch.isExact) {
      activeTransaction.setName(props.computedMatch.path, "route");
    }
    return React3.createElement(Route, { ...props, __self: this, __source: { fileName: _jsxFileName3, lineNumber: 174 } });
  };
  WrappedRoute.displayName = `sentryRoute(${componentDisplayName})`;
  (0, import_hoist_non_react_statics3.default)(WrappedRoute, Route);
  return WrappedRoute;
}

// node_modules/@sentry/react/esm/reactrouterv6.js
var import_hoist_non_react_statics4 = __toESM(require_hoist_non_react_statics_cjs());
var import_react = __toESM(require_react());
var _jsxFileName4 = "/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/reactrouterv6.tsx";
var activeTransaction2;
var _useEffect;
var _useLocation;
var _useNavigationType;
var _createRoutesFromChildren;
var _matchRoutes;
var _customStartTransaction;
var _startTransactionOnLocationChange;
var SENTRY_TAGS = {
  "routing.instrumentation": "react-router-v6"
};
function reactRouterV6Instrumentation(useEffect2, useLocation, useNavigationType, createRoutesFromChildren, matchRoutes2) {
  return (customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) => {
    const initPathName = WINDOW && WINDOW.location && WINDOW.location.pathname;
    if (startTransactionOnPageLoad && initPathName) {
      activeTransaction2 = customStartTransaction({
        name: initPathName,
        op: "pageload",
        tags: SENTRY_TAGS,
        metadata: {
          source: "url"
        }
      });
    }
    _useEffect = useEffect2;
    _useLocation = useLocation;
    _useNavigationType = useNavigationType;
    _matchRoutes = matchRoutes2;
    _createRoutesFromChildren = createRoutesFromChildren;
    _customStartTransaction = customStartTransaction;
    _startTransactionOnLocationChange = startTransactionOnLocationChange;
  };
}
function getNormalizedName(routes, location, matchRoutes2) {
  if (!routes || routes.length === 0 || !matchRoutes2) {
    return [location.pathname, "url"];
  }
  const branches = matchRoutes2(routes, location);
  let pathBuilder = "";
  if (branches) {
    for (let x = 0; x < branches.length; x++) {
      const branch = branches[x];
      const route = branch.route;
      if (route) {
        if (route.index) {
          return [branch.pathname, "route"];
        }
        const path = route.path;
        if (path) {
          const newPath = path[0] === "/" || pathBuilder[pathBuilder.length - 1] === "/" ? path : `/${path}`;
          pathBuilder += newPath;
          if (branch.pathname === location.pathname) {
            if (getNumberOfUrlSegments(pathBuilder) !== getNumberOfUrlSegments(branch.pathname) && pathBuilder.slice(-2) !== "/*") {
              return [newPath, "route"];
            }
            return [pathBuilder, "route"];
          }
        }
      }
    }
  }
  return [location.pathname, "url"];
}
function updatePageloadTransaction(location, routes) {
  if (activeTransaction2) {
    activeTransaction2.setName(...getNormalizedName(routes, location, _matchRoutes));
  }
}
function handleNavigation(location, routes, navigationType, isBaseLocation) {
  if (isBaseLocation) {
    if (activeTransaction2) {
      activeTransaction2.finish();
    }
    return;
  }
  if (_startTransactionOnLocationChange && (navigationType === "PUSH" || navigationType === "POP")) {
    if (activeTransaction2) {
      activeTransaction2.finish();
    }
    const [name, source] = getNormalizedName(routes, location, _matchRoutes);
    activeTransaction2 = _customStartTransaction({
      name,
      op: "navigation",
      tags: SENTRY_TAGS,
      metadata: {
        source
      }
    });
  }
}
function withSentryReactRouterV6Routing(Routes) {
  if (!_useEffect || !_useLocation || !_useNavigationType || !_createRoutesFromChildren || !_matchRoutes || !_customStartTransaction) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn(`reactRouterV6Instrumentation was unable to wrap Routes because of one or more missing parameters.
      useEffect: ${_useEffect}. useLocation: ${_useLocation}. useNavigationType: ${_useNavigationType}.
      createRoutesFromChildren: ${_createRoutesFromChildren}. matchRoutes: ${_matchRoutes}. customStartTransaction: ${_customStartTransaction}.`);
    return Routes;
  }
  let isBaseLocation = false;
  let routes;
  const SentryRoutes = (props) => {
    const location = _useLocation();
    const navigationType = _useNavigationType();
    _useEffect(() => {
      routes = _createRoutesFromChildren(props.children);
      isBaseLocation = true;
      updatePageloadTransaction(location, routes);
    }, [props.children]);
    _useEffect(() => {
      handleNavigation(location, routes, navigationType, isBaseLocation);
    }, [props.children, location, navigationType, isBaseLocation]);
    isBaseLocation = false;
    return import_react.default.createElement(Routes, { ...props, __self: this, __source: { fileName: _jsxFileName4, lineNumber: 249 } });
  };
  (0, import_hoist_non_react_statics4.default)(SentryRoutes, Routes);
  return SentryRoutes;
}
function wrapUseRoutes(origUseRoutes) {
  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes || !_customStartTransaction) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("reactRouterV6Instrumentation was unable to wrap `useRoutes` because of one or more missing parameters.");
    return origUseRoutes;
  }
  let isBaseLocation = false;
  return (routes, location) => {
    const SentryRoutes = (props) => {
      const Routes = origUseRoutes(routes, location);
      const locationArgObject = typeof location === "string" ? { pathname: location } : location;
      const locationObject = locationArgObject || _useLocation();
      const navigationType = _useNavigationType();
      _useEffect(() => {
        isBaseLocation = true;
        updatePageloadTransaction(locationObject, routes);
      }, [props]);
      _useEffect(() => {
        handleNavigation(locationObject, routes, navigationType, isBaseLocation);
      }, [props, locationObject, navigationType, isBaseLocation]);
      isBaseLocation = false;
      return Routes;
    };
    return import_react.default.createElement(SentryRoutes, { __self: this, __source: { fileName: _jsxFileName4, lineNumber: 294 } });
  };
}
export {
  Breadcrumbs,
  BrowserClient,
  Dedupe,
  ErrorBoundary,
  FunctionToString,
  GlobalHandlers,
  HttpContext,
  Hub,
  InboundFilters,
  INTEGRATIONS as Integrations,
  LinkedErrors,
  Profiler,
  SDK_VERSION,
  Scope,
  TryCatch,
  WINDOW,
  addBreadcrumb,
  addGlobalEventProcessor,
  captureEvent,
  captureException,
  captureMessage,
  chromeStackLineParser,
  close,
  configureScope,
  createReduxEnhancer,
  createTransport,
  defaultIntegrations,
  defaultStackLineParsers,
  defaultStackParser,
  flush,
  forceLoad,
  geckoStackLineParser,
  getCurrentHub,
  getHubFromCarrier,
  init2 as init,
  lastEventId,
  makeFetchTransport,
  makeMain,
  makeXHRTransport,
  onLoad,
  opera10StackLineParser,
  opera11StackLineParser,
  reactRouterV3Instrumentation,
  reactRouterV4Instrumentation,
  reactRouterV5Instrumentation,
  reactRouterV6Instrumentation,
  setContext,
  setExtra,
  setExtras,
  setTag,
  setTags,
  setUser,
  showReportDialog,
  startTransaction,
  useProfiler,
  winjsStackLineParser,
  withErrorBoundary,
  withProfiler,
  withScope,
  withSentryReactRouterV6Routing,
  withSentryRouting,
  wrap2 as wrap,
  wrapUseRoutes
};
//# sourceMappingURL=@sentry_react.js.map
